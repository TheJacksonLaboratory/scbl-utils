from datetime import date

from sqlalchemy import ForeignKey, null
from sqlalchemy.orm import Mapped, mapped_column, relationship, validates

from scbl_utils.core.validation import valid_str
from scbl_utils.db_models.researcher_metadata import Lab, Person, project_person_mapping
from scbl_utils.db_models.type_shortcuts import (
    int_pk,
    samplesheet_str,
    stripped_str,
    stripped_str_pk,
    unique_stripped_str,
)
from scbl_utils.defaults import PROJECT_ID_PATTERN

from .base import Base
from .disassociative import Library, Sample


class AssayType(Base):
    __tablename__ = 'assay_type'

    id: Mapped[int_pk] = mapped_column(init=False, repr=False)
    name: Mapped[unique_stripped_str] = mapped_column(index=True)


class Platform(Base):
    __tablename__ = 'platform'

    id: Mapped[int_pk] = mapped_column(init=False, repr=False)
    name: Mapped[unique_stripped_str] = mapped_column(index=True)

    assay_type_id: Mapped[int] = mapped_column(
        ForeignKey('assay_type.id'), init=False, repr=False
    )

    assay_type: Mapped[AssayType] = relationship()


class Project(Base):
    __tablename__ = 'project'

    id: Mapped[stripped_str_pk]

    lab_id: Mapped[int] = mapped_column(ForeignKey('lab.id'), init=False, repr=False)

    lab: Mapped[Lab] = relationship(back_populates='projects')
    data_sets: Mapped[list['DataSet']] = relationship(
        back_populates='project', default_factory=list, repr=False
    )
    people: Mapped[list['Person']] = relationship(
        back_populates='projects',
        default_factory=list,
        secondary=project_person_mapping,
        repr=False,
    )

    description: Mapped[stripped_str | None] = mapped_column(
        default=None, insert_default=null(), index=True
    )

    @validates('id')
    def check_id(self, key: str, id: str) -> str | None:
        checked_id = valid_str(
            string=id.upper().strip(),
            pattern=PROJECT_ID_PATTERN,
            string_name='project ID',
        )
        return checked_id if isinstance(checked_id, str) else None


# TODO: add validation for platform
class DataSet(Base, kw_only=True):
    __tablename__ = 'data_set'

    id: Mapped[int_pk] = mapped_column(init=False, repr=False)
    name: Mapped[samplesheet_str] = mapped_column(index=True)
    ilab_request_id: Mapped[stripped_str] = mapped_column(
        index=True
    )  # TODO: ilab validation

    project_id: Mapped[str] = mapped_column(
        ForeignKey('project.id'), init=False, repr=False
    )
    platform_id: Mapped[int] = mapped_column(
        ForeignKey('platform.id'), init=False, repr=False
    )
    submitter_id: Mapped[int] = mapped_column(
        ForeignKey('person.id'), init=False, repr=False
    )

    platform: Mapped[Platform] = relationship()
    project: Mapped[Project] = relationship(back_populates='data_sets')
    submitter: Mapped[Person] = relationship()

    # TODO should there be another column for the date that work was
    # begun on the dataset? this will help generate a batch_id
    date_submitted: Mapped[date] = mapped_column(default_factory=date.today)
    batch_id: Mapped[int] = mapped_column(init=False, default=None, repr=False)

    __mapper_args__ = {
        'polymorphic_on': 'platform.id',
        'polymorphic_identity': 'data_set',
    }

    @validates('batch_id')
    def set_batch_id(self, key: str, batch_id: None) -> int:
        # If it's decided that more things constitute a batch, this will
        # be easy to update.

        # Note that submitter email, institution, name, and ORCID have
        # been picked instead of the person ID because a person is not
        # assigned an ID until they enter the database.

        # There is a small likelihood that two people with the same name
        # and institution both have an autogenerated email and no ORCID.
        # If these two people submit on the same day, the batch_id of
        # the two datasets will be the same.
        # TODO: this should be fixed somehow
        to_hash = (
            self.date_submitted,
            self.submitter.email,
            self.submitter.institution_id,
            self.submitter.name,
            self.submitter.orcid,
        )
        return hash(to_hash)
